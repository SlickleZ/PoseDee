{"ast":null,"code":"import { VERSION } from \"./global.js\";\nimport { parseColors } from \"./utils/colors.js\";\nimport { isNil, isObjectLike } from './utils/helpers.js';\n/**\n * Use constructable stylesheets if supported (https://developers.google.com/web/updates/2019/02/constructable-stylesheets)\n */\nconst SUPPORTS_ADOPTING_STYLE_SHEETS = 'adoptedStyleSheets' in Document.prototype && 'replace' in CSSStyleSheet.prototype;\n/**\n * Default value for many of supported properties.\n * For example stroke, scale can be changed in 0-100 range.\n */\nconst CENTER_VALUE = 50;\n/**\n * Style for this element.\n */\nconst ELEMENT_STYLE = `:host{position:relative;display:inline-block;width:32px;height:32px}:host(.current-color) svg path[fill]{fill:currentColor}:host(.current-color) svg path[stroke]{stroke:currentColor}:host(:not(.current-color)) svg .primary path[fill]{fill:var(--lord-icon-primary, var(--lord-icon-primary-base))}:host(:not(.current-color)) svg .primary path[stroke]{stroke:var(--lord-icon-primary, var(--lord-icon-primary-base))}:host(:not(.current-color)) svg .secondary path[fill]{fill:var(--lord-icon-secondary, var(--lord-icon-secondary-base))}:host(:not(.current-color)) svg .secondary path[stroke]{stroke:var(--lord-icon-secondary, var(--lord-icon-secondary-base))}svg{position:absolute;pointer-events:none;display:block}`;\n/**\n * Current style sheet instance (if supported).\n */\nlet styleSheet;\n/**\n * Observed attributes for this custom element.\n */\nconst OBSERVED_ATTRIBUTES = [\"colors\", \"src\", \"icon\", \"state\", \"trigger\", \"loading\", \"target\", \"stroke\", \"scale\", \"axis-x\", \"axis-y\"];\n/**\n * Custom element implementation that supports rendering, customizing and controlling of our icons in simple way.\n *\n * Example:\n * ```js\n * import lottie from 'lottie-web';\n * import { Element } from 'lord-icon-element/element';\n * import { Player } from 'lord-icon-element/player';\n *\n * Element.setPlayerFactory((container, iconData) => {\n *     return new Player(\n *         lottie.loadAnimation,\n *         container,\n *         iconData,\n *     );\n * });\n *\n * customElements.define(\"lord-icon\", Element);\n * ```\n *\n * Notice: you can define this custom element, a lot easier with premade helper method: {@link index.defineElement | defineElement}.\n */\nexport class Element extends HTMLElement {\n  static _iconLoader;\n  static _playerFactory;\n  static _definedTriggers = new Map();\n  /**\n   * Get element version.\n   */\n  static get version() {\n    return VERSION;\n  }\n  /**\n   * Custom element observed attributes.\n   */\n  static get observedAttributes() {\n    return OBSERVED_ATTRIBUTES;\n  }\n  /**\n   * Assign callback responsible for loading icons. Allows our {@link element.Element | Element} to load {@link interfaces.IconData | icon data} from any source.\n   * Remember to assign _icon loader_ before defining `lord-icon` custom element to take effect.\n   *\n   * Example:\n   * ```js\n   * import lottie from 'lottie-web';\n   * import { defineElement } from 'lord-icon-element';\n   * import { Element } from 'lord-icon-element/element';\n   *\n   * Element.setIconLoader(async (name) => {\n   *     const response = await fetch(`https://example.com/${name}.json`);\n   *     return await response.json();\n   * });\n   *\n   * defineElement(lottie.loadAnimation);\n   * ```\n   *\n   * @param loader Custom icon loader callback.\n   */\n  static setIconLoader(loader) {\n    Element._iconLoader = loader;\n  }\n  /**\n   * Assign callback which create a player. Player is responsible for customizing icons and playing animations.\n   * @param loader\n   */\n  static setPlayerFactory(loader) {\n    Element._playerFactory = loader;\n  }\n  /**\n   * Define supported trigger. Triggers allows to define interaction strategy with icon.\n   * @param name\n   * @param triggerClass\n   */\n  static defineTrigger(name, triggerClass) {\n    Element._definedTriggers.set(name, triggerClass);\n  }\n  _root;\n  _isConnected = false;\n  _isReady = false;\n  _triggerInstance;\n  _assignedIconData;\n  _loadedIconData;\n  _player;\n  _intersectionObserver;\n  /**\n   * Handle attribute update.\n   * @param name\n   * @param oldValue\n   * @param newValue\n   */\n  attributeChangedCallback(name, oldValue, newValue) {\n    switch (name) {\n      case 'axis-x':\n        this.axisXChanged();\n        break;\n      case 'axis-y':\n        this.axisYChanged();\n        break;\n      default:\n        this[`${name}Changed`].call(this);\n        break;\n    }\n  }\n  /**\n   * Element connected.\n   */\n  connectedCallback() {\n    // create elements only once\n    if (!this._root) {\n      this.createElements();\n    }\n    if (this.loading === 'lazy') {\n      const callback = (entries, observer) => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting && this._intersectionObserver) {\n            this._intersectionObserver.unobserve(this);\n            this._intersectionObserver = undefined;\n            this.createPlayer();\n          }\n        });\n      };\n      this._intersectionObserver = new IntersectionObserver(callback);\n      this._intersectionObserver.observe(this);\n    } else {\n      this.createPlayer();\n    }\n    this._isConnected = true;\n  }\n  /**\n   * Element disconnected.\n   */\n  disconnectedCallback() {\n    if (this._intersectionObserver) {\n      this._intersectionObserver.unobserve(this);\n      this._intersectionObserver = undefined;\n    }\n    this.destroyPlayer();\n    this._isConnected = false;\n  }\n  /**\n   * Create DOM elements.\n   * @returns\n   */\n  createElements() {\n    // create shadow root for this element\n    this._root = this.attachShadow({\n      mode: \"open\"\n    });\n    if (SUPPORTS_ADOPTING_STYLE_SHEETS) {\n      if (!styleSheet) {\n        styleSheet = new CSSStyleSheet();\n        styleSheet.replaceSync(ELEMENT_STYLE);\n      }\n      this._root.adoptedStyleSheets = [styleSheet];\n    } else {\n      const style = document.createElement(\"style\");\n      style.innerHTML = ELEMENT_STYLE;\n      this._root.appendChild(style);\n    }\n    const container = document.createElement(\"div\");\n    container.classList.add('body');\n    this._root.appendChild(container);\n  }\n  /**\n   * Instantiate player intance on demand with assigned player factory.\n   * @returns\n   */\n  async createPlayer() {\n    // notify about missing loader\n    if (!Element._playerFactory) {\n      throw new Error('Missing player loader!');\n    }\n    // already on awaiting state\n    if (this._intersectionObserver) {\n      return;\n    }\n    const iconData = await this.loadIconData();\n    if (!iconData) {\n      return;\n    }\n    this._player = Element._playerFactory(this.animationContainer, iconData);\n    this._player.connect();\n    // assign initial properties for icon\n    if (this.state || this.colors || this.stroke || this.scale || this.axisX || this.axisY) {\n      this.player.resetProperties({\n        colors: parseColors(this.colors || ''),\n        stroke: this.stroke,\n        scale: this.scale,\n        state: this.state,\n        axis: isNil(this.axisX) && isNil(this.axisY) ? null : {\n          x: isNil(this.axisX) ? CENTER_VALUE : this.axisX,\n          y: isNil(this.axisY) ? CENTER_VALUE : this.axisY\n        }\n      });\n    }\n    // listen for ready\n    this._player.addEventListener('ready', () => {\n      if (this._triggerInstance && this._triggerInstance.onReady) {\n        this._triggerInstance.onReady();\n      }\n    });\n    // listen for refresh\n    this._player.addEventListener('refresh', () => {\n      this.refresh();\n      if (this._triggerInstance && this._triggerInstance.onRefresh) {\n        this._triggerInstance.onRefresh();\n      }\n    });\n    // listen for complete\n    this._player.addEventListener('complete', () => {\n      if (this._triggerInstance && this._triggerInstance.onComplete) {\n        this._triggerInstance.onComplete();\n      }\n    });\n    // listen for frame\n    this._player.addEventListener('frame', () => {\n      if (this._triggerInstance && this._triggerInstance.onFrame) {\n        this._triggerInstance.onFrame();\n      }\n    });\n    // refresh element instantly\n    this.refresh();\n    // create trigger (only if assigned)\n    this.triggerChanged();\n    // wait for player ready\n    await new Promise((resolve, reject) => {\n      if (this._player.isReady) {\n        resolve();\n      } else {\n        this._player.addEventListener('ready', resolve);\n      }\n    });\n    // mark ready\n    this._isReady = true;\n    // notify about ready\n    this.dispatchEvent(new CustomEvent(\"ready\"));\n  }\n  /**\n   * Destroy connected player and connected trigger.\n   * Player is recreated on every icon data change.\n   */\n  destroyPlayer() {\n    // mark not ready\n    this._isReady = false;\n    // clear stored icon data\n    this._loadedIconData = undefined;\n    // remove trigger\n    if (this._triggerInstance) {\n      if (this._triggerInstance.onDisconnected) {\n        this._triggerInstance.onDisconnected();\n      }\n      this._triggerInstance = undefined;\n    }\n    // remove player\n    if (this._player) {\n      this._player.disconnect();\n      this._player = undefined;\n    }\n  }\n  /**\n   * Load icon with assigned icon loader or source indicated by src attribute.\n   * @returns Icon data.\n   */\n  async loadIconData() {\n    let iconData = this.iconData;\n    if (!iconData) {\n      if (this.icon && Element._iconLoader) {\n        this._loadedIconData = iconData = await Element._iconLoader(this.icon);\n      } else if (this.src) {\n        const response = await fetch(this.src);\n        this._loadedIconData = iconData = await response.json();\n      }\n    }\n    return iconData;\n  }\n  /**\n   * Synchronize element state with player.\n   */\n  refresh() {\n    this.movePaletteToCssVariables();\n  }\n  /**\n   * Update defaults for css variables.\n   * Notice: css variables take precedence over colors assigned by other methods!\n   */\n  movePaletteToCssVariables() {\n    for (const [key, value] of Object.entries(this.player.colors || {})) {\n      this.animationContainer.style.setProperty(`--lord-icon-${key}-base`, value);\n    }\n  }\n  /**\n   * Target attribute changed. Element should reload it's trigger.\n   */\n  targetChanged() {\n    this.triggerChanged();\n  }\n  /**\n   * Loading attribute changed.\n   */\n  loadingChanged() {}\n  /**\n   * Trigger attribute changed. Disconnect old trigger and instantiate new one.\n   */\n  triggerChanged() {\n    if (this._triggerInstance) {\n      if (this._triggerInstance.onDisconnected) {\n        this._triggerInstance.onDisconnected();\n      }\n      this._triggerInstance = undefined;\n    }\n    if (!this.trigger || !this._player) {\n      return;\n    }\n    const TriggerClass = Element._definedTriggers.get(this.trigger);\n    if (!TriggerClass) {\n      throw new Error(`Can't use unregistered trigger!`);\n    }\n    const targetElement = this.target ? this.closest(this.target) : null;\n    this._triggerInstance = new TriggerClass(this, targetElement || this, this._player);\n    if (this._triggerInstance.onConnected) {\n      this._triggerInstance.onConnected();\n    }\n    if (this._player.isReady && this._triggerInstance.onReady) {\n      this._triggerInstance.onReady();\n    }\n  }\n  /**\n   * Colors attribute changed. Notify about new value player.\n   */\n  colorsChanged() {\n    if (!this.player) {\n      return;\n    }\n    this.player.colors = parseColors(this.colors || '');\n  }\n  /**\n   * Stroke attribute changed. Notify about new value player.\n   */\n  strokeChanged() {\n    if (!this.player) {\n      return;\n    }\n    this.player.stroke = this.stroke;\n  }\n  /**\n   * State attribute changed. Notify about new value player.\n   */\n  stateChanged() {\n    if (!this.player) {\n      return;\n    }\n    this.player.state = this.state;\n  }\n  /**\n   * Scale attribute changed. Notify about new value player.\n   */\n  scaleChanged() {\n    if (!this.player) {\n      return;\n    }\n    this.player.scale = this.scale;\n  }\n  /**\n   * Axis attribute changed. Notify about new value player.\n   */\n  axisXChanged() {\n    if (!this.player) {\n      return;\n    }\n    this.player.axis = {\n      x: isNil(this.axisX) ? CENTER_VALUE : this.axisX,\n      y: isNil(this.axisY) ? CENTER_VALUE : this.axisX\n    };\n  }\n  /**\n   * Axis attribute changed. Notify about new value player.\n   */\n  axisYChanged() {\n    if (!this.player) {\n      return;\n    }\n    this.player.axis = {\n      x: isNil(this.axisX) ? CENTER_VALUE : this.axisX,\n      y: isNil(this.axisY) ? CENTER_VALUE : this.axisY\n    };\n  }\n  /**\n   * Icon attribute changed. Reload our player.\n   */\n  iconChanged() {\n    if (!this._isConnected) {\n      return;\n    }\n    this.destroyPlayer();\n    this.createPlayer();\n  }\n  /**\n   * Src attribute changed. Reload our player.\n   */\n  srcChanged() {\n    if (!this._isConnected) {\n      return;\n    }\n    this.destroyPlayer();\n    this.createPlayer();\n  }\n  /**\n   * Update current icon. We can assign here icon name handled by {@link interfaces.IconLoader | icon loader} or right away {@link interfaces.IconData | icon data}.\n   */\n  set icon(value) {\n    if (value && isObjectLike(value)) {\n      if (this._assignedIconData !== value) {\n        this._assignedIconData = value;\n        if (this.hasAttribute('icon')) {\n          this.removeAttribute('icon');\n        } else {\n          this.iconChanged();\n        }\n      }\n    } else {\n      const oldIconData = this._assignedIconData;\n      this._assignedIconData = undefined;\n      if (value && typeof value === 'string') {\n        this.setAttribute('icon', value);\n      } else {\n        this.removeAttribute('icon');\n        if (oldIconData) {\n          this.iconChanged();\n        }\n      }\n    }\n  }\n  /**\n   * Get icon (icon name or assiged directly {@link interfaces.IconData | icon data})\n   */\n  get icon() {\n    return this._assignedIconData || this.getAttribute('icon');\n  }\n  /**\n   * Set src value.\n   */\n  set src(value) {\n    if (value) {\n      this.setAttribute('src', value);\n    } else {\n      this.removeAttribute('src');\n    }\n  }\n  /**\n   * Get src value.\n   */\n  get src() {\n    return this.getAttribute('src');\n  }\n  /**\n   * Set state value.\n   *\n   * Notice: you can check available states for loaded icon with `states` property.\n   */\n  set state(value) {\n    if (value) {\n      this.setAttribute('state', value);\n    } else {\n      this.removeAttribute('state');\n    }\n  }\n  /**\n   * Get state value.\n   */\n  get state() {\n    return this.getAttribute('state');\n  }\n  /**\n   * Set colors value. We support here string format with comma color separation: \"primary:#fdd394,secondary:#03a9f4\".\n   *\n   * Example:\n   * ```html\n   * <lord-icon colors=\"primary:#fdd394,secondary:#03a9f4\" src=\"/icons/confetti.json\"></lord-icon>\n   * ```\n   */\n  set colors(value) {\n    if (value) {\n      this.setAttribute('colors', value);\n    } else {\n      this.removeAttribute('colors');\n    }\n  }\n  /**\n   * Get colors value.\n   */\n  get colors() {\n    return this.getAttribute('colors');\n  }\n  /**\n   * Set trigger value. Provide name of already defined trigger!\n   */\n  set trigger(value) {\n    if (value) {\n      this.setAttribute('trigger', value);\n    } else {\n      this.removeAttribute('trigger');\n    }\n  }\n  /**\n   * Get trigger value.\n   */\n  get trigger() {\n    return this.getAttribute('trigger');\n  }\n  /**\n   * Set loading strategy. By default {@link interfaces.IconData | icon data} are loaded instantly on {@link interfaces.IPlayer | player} initialisation.\n   * It's possible to delay icon loading (with _src_ and _icon_ attribute) by changing _loading_ value to _lazy_.\n   */\n  set loading(value) {\n    if (value) {\n      this.setAttribute('loading', value);\n    } else {\n      this.removeAttribute('loading');\n    }\n  }\n  /**\n   * Get loading value.\n   */\n  get loading() {\n    if (this.getAttribute('loading') && this.getAttribute('loading').toLowerCase() === 'lazy') {\n      return 'lazy';\n    }\n    return null;\n  }\n  /**\n   * Assign query selector for closest element target used for listening events.\n   */\n  set target(value) {\n    if (value) {\n      this.setAttribute('target', value);\n    } else {\n      this.removeAttribute('target');\n    }\n  }\n  /**\n   * Get target value.\n   */\n  get target() {\n    return this.getAttribute('target');\n  }\n  /**\n   * Set stroke value (in range 0-100).\n   */\n  set stroke(value) {\n    if (isNil(value)) {\n      this.removeAttribute('stroke');\n    } else {\n      this.setAttribute('stroke', '' + value);\n    }\n  }\n  /**\n   * Get stroke value.\n   */\n  get stroke() {\n    if (this.hasAttribute('stroke')) {\n      return parseFloat(this.getAttribute('stroke'));\n    }\n    return null;\n  }\n  /**\n   * Set scale value (in range 0-100).\n   */\n  set scale(value) {\n    if (isNil(value)) {\n      this.removeAttribute('scale');\n    } else {\n      this.setAttribute('scale', '' + value);\n    }\n  }\n  /**\n   * Get scale value.\n   */\n  get scale() {\n    if (this.hasAttribute('scale')) {\n      return parseFloat(this.getAttribute('scale'));\n    }\n    return null;\n  }\n  /**\n   * Set axisX value.\n   */\n  set axisX(value) {\n    if (isNil(value)) {\n      this.removeAttribute('axis-x');\n    } else {\n      this.setAttribute('axis-x', '' + value);\n    }\n  }\n  /**\n   * Get axisX value.\n   */\n  get axisX() {\n    if (this.hasAttribute('axis-x')) {\n      return parseFloat(this.getAttribute('axis-x'));\n    }\n    return null;\n  }\n  /**\n   * Set axisY value.\n   */\n  set axisY(value) {\n    if (isNil(value)) {\n      this.removeAttribute('axis-y');\n    } else {\n      this.setAttribute('axis-y', '' + value);\n    }\n  }\n  /**\n   * Get axisY value.\n   */\n  get axisY() {\n    if (this.hasAttribute('axis-y')) {\n      return parseFloat(this.getAttribute('axis-y'));\n    }\n    return null;\n  }\n  /**\n   * Access animation {@link interfaces.IPlayer | player}.\n   */\n  get player() {\n    return this._player;\n  }\n  /**\n   * Check whether the element is ready (instantiated player, trigger and loaded icon data).\n   *\n   * You can listen for element ready with event listener:\n   * ```js\n   * element.addEventListener('ready', () => {});\n   * ```\n   */\n  get isReady() {\n    return this._isReady;\n  }\n  /**\n   * Access connected {@link interfaces.ITrigger | trigger} instance.\n   */\n  get triggerInstance() {\n    return this._triggerInstance;\n  }\n  /**\n   * Access animation container element.\n   */\n  get animationContainer() {\n    return this._root.lastElementChild;\n  }\n  /**\n   * Access loaded {@link interfaces.IconData | icon data}.\n   */\n  get iconData() {\n    return this._assignedIconData || this._loadedIconData;\n  }\n}","map":{"version":3,"names":["VERSION","parseColors","isNil","isObjectLike","SUPPORTS_ADOPTING_STYLE_SHEETS","Document","prototype","CSSStyleSheet","CENTER_VALUE","ELEMENT_STYLE","_iconLoader","_playerFactory","_definedTriggers","Map","version","observedAttributes","OBSERVED_ATTRIBUTES","setIconLoader","loader","Element","setPlayerFactory","defineTrigger","name","triggerClass","set","axisYChanged","createElements","loading","callback","entries","observer","forEach","entry","isIntersecting","_intersectionObserver","unobserve","undefined","createPlayer","IntersectionObserver","_isConnected","disconnectedCallback","_root","attachShadow","mode","styleSheet","replaceSync","style","document","createElement","innerHTML","appendChild","container","classList","add","Error","_player","animationContainer","iconData","connect","state","colors","stroke","scale","axisX","axisY","player","resetProperties","axis","x","y","addEventListener","_triggerInstance","onReady","refresh","onRefresh","onComplete","onFrame","Promise","resolve","reject","isReady","_isReady","dispatchEvent","CustomEvent","destroyPlayer","_loadedIconData","onDisconnected","disconnect","loadIconData","icon","src","response","fetch","json","movePaletteToCssVariables","key","value","Object","setProperty","targetChanged","triggerChanged","loadingChanged","trigger","TriggerClass","get","targetElement","target","closest","onConnected","colorsChanged","stateChanged","scaleChanged","axisXChanged","iconChanged","srcChanged","_assignedIconData","hasAttribute","removeAttribute","oldIconData","setAttribute","getAttribute","toLowerCase","parseFloat","triggerInstance","lastElementChild"],"sources":["../src/element.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}